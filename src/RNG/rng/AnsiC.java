package RNG.rng;


import RNG.validator.Validation;

import java.math.BigDecimal;
import java.math.BigInteger;

/**
 * @author Montahaee
 * @version 1.0
 * @created 08-Oct-2022 5:38:28 PM
 */
public class AnsiC extends LCG {

	public AnsiC() {
		this.seed = new BigInteger("12345");
		this.multiplier = new BigInteger(" 1103515245");
		this.increment = this.seed;
		this.modulus = BigDecimal.valueOf(Math.pow(2.0,31)).toBigInteger();
	}

	/**
	 * @return The clone operation returns one of the LCG types(subclasses).
	 */
	@Override
	public LCG clone() {
		return new AnsiC();
	}

//	private final int seed;
//	private final int multiplier;
//	private final int increment;
//	private final int modulus;
//	private final int order;
//	private final int[] sequence;
//
//	/**
//	 * @param that_multiplier as linear factor to LCG as integer constant.
//	 * @param that_modulus    in the LCG as integer constant.
//	 * @param that_increment  element in the LCG as integer constant.
//	 * @param that_seed       as start value in the LCG.
//	 * @param that_order      refers to the size of the generated random numbers.
//	 */
//	public AnsiC(int that_seed, int that_multiplier,
//								 int that_increment, int that_order, int that_modulus) {
//		super();
////		boolean isLCG = true;
////		isLCG
//		if (!((0 <= that_multiplier && that_multiplier < that_modulus) &&
//				(0 <= that_increment  && that_increment  < that_modulus) &&
//				(0 <= that_seed       && that_seed       < that_modulus))) {
//			throw new IllegalArgumentException("The input parameter to construct a LCG cannot be fulfilled " +
//					"the obligated condition for a LCG!");
//		}
//		if (!(0 < that_order)) {
//			throw new IllegalArgumentException("The order of a sequence is greater than or equal to one!");
//		}
//		this.seed = that_seed;
//		this.multiplier = that_multiplier;
//		this.increment = that_increment;
//		this.modulus = that_modulus;
//		this.order = that_order;
//		this.sequence =
//
//	/**
//	 * @param rv is abbreviation of random variable.
//	 * @return cumulative distribution function.
//	 */
//	@Override
//	public double cdf(double rv) {
//		return 0;
//	}
//
//	/**
//	 * @param rvs is abbreviation of random variables.
//	 * @return excepted value for random numbers.
//	 */
//	@Override
//	public double exv(int[] rvs) {
//		return 0;
//	}
//
//	/**
//	 * @param rv is abbreviation of random variable.
//	 * @return probability density function.
//	 */
//	@Override
//	public double pdf(double rv) {
//		return 0;
//	}
//
//	/**
//	 * @param rv is abbreviation of random variable.
//	 * @return probability mass function associated with discrete random variables generated by LCG.
//	 */
//	@Override
//	public double pmf(int rv) {
//		return 0;
//	}
//
//	/**
//	 * @param multiplier as linear factor to LCG as integer constant.
//	 * @param modulus    in the LCG as integer constant.
//	 * @param increment  element in the LCG as integer constant.
//	 * @param seed       as start value in the LCG.
//	 * @param order     refers to the size of the generated random numbers.
//	 * @return sequential integer random numbers using LCG algorithm.
//	 */
//	@Override
//	public int[] random_variable(int multiplier, int modulus, int increment, int seed, int order) {
//		if (increment == 0) {
//			throw new IllegalArgumentException("The increment of the 'Ansi-C' is a positive number.");
//		}
//		return new int[0];
//	}
//
//	/**
//	 * @param rvs refers to random variables.
//	 * @return the range of the cdf() function.
//	 */
//	@Override
//	public Interval range(int[] rvs) {
//		return null;
//	}
//
//	/**
//	 * @param random_numbers are generated by LCG.
//	 * @return true/false according to result of{@link #<Validation>}.
//	 */
//	@Override
//	public boolean validated(int[] random_numbers) {
//		return false;
//	}
//
//	/**
//	 * @param min random variable, which generated by LCG.
//	 * @param max random variable, which generated by LCG.
//	 * @return variance for a continues uniform distribution with [min, max]
//	 */
//	@Override
//	public double var(double min, double max) {
//		return 0;
//	}
}//end Ansi-C